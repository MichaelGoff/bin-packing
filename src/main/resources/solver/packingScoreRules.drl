package solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoftdouble.HardSoftDoubleScoreHolder;

import domain.Packing;
import domain.Part;
import domain.Platform;

global HardSoftDoubleScoreHolder scoreHolder;

//*****************
// Hard Constraints
//*****************

rule "partOverlap"
    when
        $p1 : Part($id : id)
        $p2 : Part(id > $id)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -$p2.intersectArea($p1));
        System.out.println("partOverlap fired");
end

rule "outOfPlatformBoundsWidth"
    when
        $platform : Platform($width : width)
        $part : Part(platform == $platform, $partWidth : width + coordinates.getX())
        $compareWidth : Number($partWidth > $width)

    then
        scoreHolder.addHardConstraintMatch(kcontext, $width - $compareWidth.doubleValue());
        System.out.println("outOfPlatformBoundsWidth fired");
end

rule "outOfPlatformBoundsHeight"
    when
        $platform : Platform($height : height)
        $part : Part(platform == $platform, $partHeight : height + coordinates.getY())
        $compareHeight : Number($partHeight > $height)

    then
        scoreHolder.addHardConstraintMatch(kcontext, $height - $compareHeight.doubleValue());
        System.out.println("outOfPlatformBoundsHeight fired");
end

rule "partNotPlaced"
    when
        $part : Part(platform == null)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10.0);
        System.out.println("partNotPlaced fired");
end

//*****************
// Soft Constraints
//*****************

rule "leftoverSpace"
    when
        Platform($l : leftoverArea)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -$l);
        System.out.println("leftoverSpace fired");
end